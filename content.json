{"pages":[{"title":"About","date":"2020-05-05T07:25:17.194Z","path":"about/index.html","text":"关于我自己 2018年新加坡 关于编程 专注业务,针对实际场景 兴趣爱好旅行、篮球、音乐、 一句话 努力才有回报 重大事件 2019年春节 我结婚了"},{"title":"Categories","date":"2020-05-05T04:10:58.936Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-05-05T04:10:59.084Z","path":"tags/index.html","text":""},{"title":"","date":"2020-05-05T04:29:22.309Z","path":"/404.html","text":"Error 404 Not Found - 您访问的页面不存在~"}],"posts":[{"title":"常用工具汇总","date":"2020-05-06T02:21:33.589Z","path":"wiki/tool/工具汇总/","text":"一、免费且开源的流程图工具 Draw.io二、itest(爱测试) 4.5.2 发布，BUG 跟踪管理 &amp; 敏捷测试管理软件三、实现HTML5网站中常见的拖拽上传文件 https://www.toutiao.com/i6745411404561383939/ 四、mysql常用函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105一、数学函数ABS(x) 返回x的绝对值BIN(x) 返回x的二进制（OCT返回八进制，HEX返回十六进制）CEILING(x) 返回大于x的最小整数值EXP(x) 返回值e（自然对数的底）的x次方FLOOR(x) 返回小于x的最大整数值GREATEST(x1,x2,...,xn) 返回集合中最大的值LEAST(x1,x2,...,xn) 返回集合中最小的值LN(x) 返回x的自然对数LOG(x,y) 返回x的以y为底的对数MOD(x,y) 返回x/y的模（余数）PI() 返回pi的值（圆周率）RAND() 返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。ROUND(x,y) 返回参数x的四舍五入的有y位小数的值SIGN(x) 返回代表数字x的符号的值SQRT(x) 返回一个数的平方根TRUNCATE(x,y) 返回数字x截短为y位小数的结果二、聚合函数(常用于GROUP BY从句的SELECT查询中)AVG(col)返回指定列的平均值COUNT(col)返回指定列中非NULL值的个数MIN(col)返回指定列的最小值MAX(col)返回指定列的最大值SUM(col)返回指定列的所有值之和GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果三、字符串函数ASCII(char)返回字符的ASCII码值BIT_LENGTH(str)返回字符串的比特长度CONCAT(s1,s2...,sn)将s1,s2...,sn连接成字符串CONCAT_WS(sep,s1,s2...,sn)将s1,s2...,sn连接成字符串，并用sep字符间隔INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果FIND_IN_SET(str,list)分析逗号分隔的list列表，如果发现str，返回str在list中的位置LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果LEFT(str,x)返回字符串str中最左边的x个字符LENGTH(s)返回字符串str中的字符数LTRIM(str) 从字符串str中切掉开头的空格POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置QUOTE(str) 用反斜杠转义str中的单引号REPEAT(str,srchstr,rplcstr)返回字符串str重复x次的结果REVERSE(str) 返回颠倒字符串str的结果RIGHT(str,x) 返回字符串str中最右边的x个字符RTRIM(str) 返回字符串str尾部的空格STRCMP(s1,s2)比较字符串s1和s2TRIM(str)去除字符串首部和尾部的所有空格UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果四、日期和时间函数CURDATE()或CURRENT_DATE() 返回当前的日期CURTIME()或CURRENT_TIME() 返回当前的时间DATE_ADD(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值DATE_SUB(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7)DAYOFMONTH(date) 返回date是一个月的第几天(1~31)DAYOFYEAR(date) 返回date是一年的第几天(1~366)DAYNAME(date) 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳tsHOUR(time) 返回time的小时值(0~23)MINUTE(time) 返回time的分钟值(0~59)MONTH(date) 返回date的月份值(1~12)MONTHNAME(date) 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);NOW() 返回当前的日期和时间QUARTER(date) 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);WEEK(date) 返回日期date为一年中第几周(0~53)YEAR(date) 返回日期date的年份(1000~9999)五、加密函数AES_ENCRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储AES_DECRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法解密后的结果DECODE(str,key) 使用key作为密钥解密加密字符串strENCRYPT(str,salt) 使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串strENCODE(str,key) 使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储MD5() 计算字符串str的MD5校验和PASSWORD(str) 返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。SHA() 计算字符串str的安全散列算法(SHA)校验和六、控制流函数MySQL有4个函数是用来进行条件操作的，这些函数可以实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台。MySQL控制流函数：CASE WHEN[test1] THEN [result1]...ELSE [default] END如果testN是真，则返回resultN，否则返回defaultCASE [test] WHEN[val1] THEN [result]...ELSE [default]END 如果test和valN相等，则返回resultN，否则返回defaultIF(test,t,f) 如果test是真，返回t；否则返回fIFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1七、格式化函数DATE_FORMAT(date,fmt) 依照字符串fmt格式化日期date值FORMAT(x,y) 把x格式化为以逗号隔开的数字序列，y是结果的小数位数INET_ATON(ip) 返回IP地址的数字表示INET_NTOA(num) 返回数字所代表的IP地址TIME_FORMAT(time,fmt) 依照字符串fmt格式化时间time值八、类型转化函数为了进行数据类型转化，MySQL提供了CAST()函数，它可以把一个值转化为指定的数据类型。类型有：BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED九、系统信息函数DATABASE() 返回当前数据库名BENCHMARK(count,expr) 将表达式expr重复运行count次CONNECTION_ID() 返回当前客户的连接IDFOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数USER()或SYSTEM_USER() 返回当前登陆用户名VERSION() 返回MySQL服务器的版本 五、ps插件：Background Image Plus +六、docker 图形化工具portainer ，shipyard七、多机定时任务可视化管理系统Gocron分享 项目GitHub地址: https://github.com/ouqiang/gocron 八、分享几个浏览器的API接口(很实用) https://www.toutiao.com/i6682529032929542669/ 九、MProxy是一个基于mysql协议，使用swoole 开发的mysql数据库连接池 https://www.toutiao.com/i6755856450158854664/ 十、WEB大并发之Nginx优化秘籍 https://www.toutiao.com/i6747547801699222024/ 十一、Redis 到底是怎么实现 -&gt;附近的人 https://www.toutiao.com/i6747559205139382791/ 十二、如何理解CGI,FastCGI,php-fpm https://www.toutiao.com/i6744630391568597516/ 十三、 PHP调试之ChromePHP十四、 基础也很重要！PHP中令人困惑的strtotime，有时也会闹些小脾气 https://www.toutiao.com/c/user/62018430890/#mid=1639681391650823 十五、 使用 PHP 实现 LRU 缓存淘汰算法 https://www.toutiao.com/i6746606879931105805/ 十六、 JWT与Session的比较 https://www.toutiao.com/i6737442710434628103/ 十七、 抽象类与接口的区别 https://www.toutiao.com/i6670462347686969860/ 十八、 PHP并行请求接口 https://www.toutiao.com/i6721889491918782983/ 十九、 用真实案例来了解PHP底层技术原理及代码优化建议 https://www.toutiao.com/i6723170171646640644/ 二十、通过nginx反向代理实现跨域访问 https://www.toutiao.com/i6723179273017885196/ 二十一、十八般武艺之Nginx踩坑总结 https://www.toutiao.com/i6722699822328971783/ 二十二、PHP多任务，并发并行，多线程，协程等知识点理解 https://www.toutiao.com/i6723083914933436942/ 二十三、PHP 7.4类型属性实例详解 https://www.toutiao.com/i6722262748182348296/ 二十四、Redis,那你们知道三大衍生数据结构吗 https://www.toutiao.com/i6719076021229847043/ 二十五、redis 和 memcached 有什么区别 https://www.toutiao.com/item/6719410555750187527/ 基于分布式锁的防止重复请求解决方案（值得收藏） https://www.toutiao.com/item/6718897355686412807/ 超详细的MySQL binlog总结，值得收藏 https://www.toutiao.com/item/6716082287168979469/ MySql快速插入百万条数据「巴分巴秒」 https://www.toutiao.com/item/6713815180104434187/ Github上 10 个开源免费且优秀的后台控制面板 https://www.toutiao.com/item/6683377252178067981/ JSON Web Token - 在Web应用间安全地传递信息 https://www.toutiao.com/item/6679714227688571404/ 推荐九个堪称神器的命令行工具给程序员们 https://www.toutiao.com/item/6688105611495735812/ 程序猿30个骚操作 https://www.toutiao.com/item/6688319659667620359/ mysql主键索引和普通索引之间的区别是什么  https://www.toutiao.com/item/6688808031032967688/ 这 10 款堪称神器的插件，让你的 Chrome 成为最好用的浏览器 https://www.toutiao.com/item/6690440291205251588/ Kafka、RabbitMQ、RocketMQ、ActiveMQ 到底该选用哪个？ https://www.toutiao.com/item/6689710266097074700/ 开发神器，全能程序员就在这里 https://www.toutiao.com/item/6691461187449651719/ IntelliJ IDEA 18个常用插件，动图演示，让效率成为习惯 https://www.toutiao.com/item/6694088151943610884/ 一文搞懂Nginx限流，原来这么简单 https://www.toutiao.com/item/6694571806835081742/ 详解Redis 主从复制及主从复制原理 https://www.toutiao.com/item/6693803701817049608/ SQL高级知识——递归查询 https://www.toutiao.com/item/6694050855185809933/ 15年前的压测工具依然是运维必备，600 行代码实现最高 30k 并发 https://www.toutiao.com/item/6695638547438764558/ 19条MySQL优化经验 https://www.toutiao.com/item/6670689051776909837/ Sentinel哨兵机制实现Redis的高可用 https://www.toutiao.com/item/6691809335594451460/ 你本可以少写些 if-else https://www.toutiao.com/item/6697113412352082440/ 使用canal增量同步mysql数据库信息到ElasticSearch https://www.toutiao.com/item/6706096293032231432/ “分布式事务”，这次彻底懂了 https://www.toutiao.com/item/6707131456386236940/ 基于Electron实现的PC桌面聊天软件 https://www.toutiao.com/item/6709286488976130572/ 有了docsify神器，从此爱上看文档 https://www.toutiao.com/item/6717631819438621191/ 70条常用Linux命令，助你完成小白到大神的转变 https://www.toutiao.com/item/6717117096012022286/ 扫盲，为什么分布式一定要有Redis? https://www.toutiao.com/item/6717771071157699079/ 我想说：mysql的join真的很弱 https://www.toutiao.com/item/6718552839372669448/ 你的项目中有Redis吗？Get完这篇你能掌握Redis60%（推荐收藏） https://www.toutiao.com/item/6717964909688128011/ mysql开发理论：搞懂什么是长连接，短连接和连接池 https://www.toutiao.com/item/6718702794125083150/ 100个Laravel开发人员下载量最高的扩展包 https://www.toutiao.com/item/6721915619194700302/ 2019年360PHP工程师面试题 https://www.toutiao.com/item/6722683385396855310/ 神奇的 SQL 之子查询，细节满满 https://www.toutiao.com/item/6723071276455297548/ PHP的微服务框架预览 https://www.toutiao.com/item/6727168703365923339/ 简述PHP如何实现语音识别功能 https://www.toutiao.com/item/6733463929592218125/ php 的反射机制是什么？详解PHP反射API` https://www.toutiao.com/item/6727067503802974727/ 多平台统一，小程序跨平台开发统一解决方案——Antmove https://www.toutiao.com/item/6723159018186998275/ 针对php使用tars二进制协议的整体运维、RPC等一系列的解决方案 https://www.toutiao.com/item/6722611925814870531/ 分享一款MySQL语句优化辅助工具–DBA必备 https://www.toutiao.com/item/6743570924152291843/ Workerman通信框架-协议Http类解析 https://www.toutiao.com/item/6743570924152291843/ 数据同步工具otter（一）谈谈binlog和canal https://www.toutiao.com/item/6731594561778352647/ 进程(process)，作为操作系统结构的基础，多种状态下的情形分析 https://www.toutiao.com/item/6744874472232190475/ 谈谈mongodb,mysql的区别和具体应用场景 https://www.toutiao.com/item/6722071545943949831/ 我以为我对Kafka很了解，直到我看了此文章 https://www.toutiao.com/item/6724572557472694796/ MySQL表锁，以为自己懂了，结果一个答对的都没有 https://www.toutiao.com/item/6742110043904147980/ 接口设计技巧和最佳实践 https://www.toutiao.com/item/6732643141809078798/ nginx配置静态资源与动态访问分离 https://www.toutiao.com/item/6738259493387239949/ 理解 PHP 依赖注入 和 控制反转 https://www.toutiao.com/item/6737855911936655885/ Laravel实现定时发布任务 https://www.toutiao.com/item/6737526429862330894/ 用 Authing 10分钟实现单点登录（SSO） https://www.toutiao.com/item/6726060529799922187/ php设置错误级别 https://www.toutiao.com/item/6746615399149732356/","tags":[{"name":"tool","slug":"tool","permalink":"https://superver.github.io/tags/tool/"}],"categories":[{"name":"tool","slug":"tool","permalink":"https://superver.github.io/categories/tool/"}]},{"title":"redis常用面试问答","date":"2020-05-05T23:01:08.040Z","path":"wiki/resume/redis_为啥会快/","text":"一、Redis为什么是单线程单线程模型,没有多余的cpu上下文切换,而且也不用设计内部锁机制,redis 单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程,因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了; 二、Redis为什么这么快1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路I/O复用模型，非阻塞IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 三、多路I/O复用模型，非阻塞IO下面举一个例子，模拟一个tcp服务器处理30个客户socket。 假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择： 1.第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。 这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。 2.第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。这种类似于为每一个用户创建一个进程或者线程处理连接。 3.第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。 这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。 针对上面的举例在Redis中表现为 有30个redis客户端（考生）与redis服务器的网络连接模块（监考老师）保持TCP连接，客户端会不定时的发送请求给服务器，当有一个redis客户端发起请求，会触发unix系统像epoll这样的系统调用，Redis的I/O 多路复用模块封装了底层的epoll这样的 I/O 多路复用函数，然后转发到相应的事件处理器。 最后多路I/O复用模型图 文件事件处理器使用 I/O 多路复用模块同时监听多个 FD（文件描述符），当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。 虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。","tags":[{"name":"redis","slug":"redis","permalink":"https://superver.github.io/tags/redis/"}],"categories":[{"name":"resume","slug":"resume","permalink":"https://superver.github.io/categories/resume/"}]},{"title":"life is long long journey","date":"2020-05-05T06:46:10.069Z","path":"wiki/life/生活_感悟/","text":"生活是一段长长的旅行 生活是一段奇妙的旅行，每一处风景都是回忆 即使你不在我身边，我也要用我的眼睛，帮你问候泸沽湖的旖旎风光。 旅行不在乎终点，而是在意途中的人和事，还有那些完美的记忆和景色。 青春随着年纪的长大一切都渐行渐远，充斥着柴米油盐","tags":[{"name":"life","slug":"life","permalink":"https://superver.github.io/tags/life/"}],"categories":[{"name":"life","slug":"life","permalink":"https://superver.github.io/categories/life/"}]},{"title":"nginx模块配置","date":"2020-05-05T06:02:56.652Z","path":"wiki/blog/nginx/nginx_php-fpm_配置/","text":"server配置123loction.\\&#123; fast_cgi_param : inclue fast-params;&#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://superver.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"https://superver.github.io/tags/linux/"}],"categories":[{"name":"blog","slug":"blog","permalink":"https://superver.github.io/categories/blog/"},{"name":"nginx","slug":"blog/nginx","permalink":"https://superver.github.io/categories/blog/nginx/"}]},{"title":"php_常用函数","date":"2020-05-05T05:57:22.091Z","path":"wiki/blog/php/php_常用函数/","text":"扩展函数常1array_coloumn($arr,$index,$key); php常用算法-冒泡 12345678910111213141516171819function BubbleSort($arr)&#123; if(empty($arr) || count($arr)&lt;=1 ) return $arr; $count = count($arr); $jmax = $count -1; for($i=0;$i&lt;$count,$i++)&#123; for($j=$i;$j&lt;$jmax;$j++)&#123; if($arr[$j]&gt;$arr[$i])&#123; //交换位置 $tmp = $arr[$j]; $arr[$j] = $arr[$i]; $arr[$i] = $tmp; &#125; &#125; &#125; return $arr; &#125; php常用算法-快速 123456789101112131415161718192021function quickSort($arr)&#123; if(empty($arr) || count($arr)&lt;=1 ) return $arr; $mid =$arr[0]; $len =count($arr); $right = $left = []; for($i=0;$i&lt;$arr;$i++)&#123; if($arr[$i]&gt;$mid)&#123; $right[] = $arr[$i]; &#125;else&#123; $left[] = $arr[$i]; &#125; &#125; $right = quickSort($right); $left = quickSort($left); return array_merge($right,array($mid),$right); &#125;","tags":[{"name":"php","slug":"php","permalink":"https://superver.github.io/tags/php/"}],"categories":[{"name":"blog","slug":"blog","permalink":"https://superver.github.io/categories/blog/"},{"name":"php","slug":"blog/php","permalink":"https://superver.github.io/categories/blog/php/"}]},{"title":"【建强】wiki 集合","date":"2020-05-05T04:10:59.939Z","path":"wiki/index/","text":"@blogphp版聚合支付 @blogYii框架干货集合 @blogphp知识点集合 🐘 A little Tips in my Code Career with PHP 🐘","tags":[],"categories":[]},{"title":"php_引用计数与gc","date":"2020-01-10T13:28:59.000Z","path":"wiki/blog/php/php_引用计数与GC/","text":"进行php扩展开发的时候会遇到一些问题，就是php用户态空间将变量传递到扩展层面c层调用的时候，会出现一些问题，下面的例子是一个timer定时器的例子。用户空间会传递一个回调函数给timer扩展接口，那么实际回调函数被调用的地方是c层。但是该回调函数变量本身是由用户空间申请并交由php内核gc管理的，如果扩展函数内不做任何操作，那么当切换到用户空间时php内核会判断该变量需要回收，然后扩展函数就会空指针异常等 当扩展函数内该php变量生命周期使用结束后，任然需要考虑垃圾回收的问题，并不是在扩展函数内简单free(data)就可以的，需要调用php内核引用计数接口等进行变量的回收以及gc等，最后交由php内核gc管理。当然扩展函数内由c自行申请管理的内存可以自己释放 扩展函数定义示例12345678910111213PHP_METHOD(timer_obj,tick)&#123; php_lib_timer_callback *fci = (php_lib_timer_callback *)malloc(sizeof(php_lib_timer_callback)); //强制传入两个参数 ZEND_PARSE_PARAMETERS_START(2, 2) Z_PARAM_LONG(fci-&gt;seconds) Z_PARAM_FUNC(fci-&gt;fci,fci-&gt;fcc) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); long id = create_time_event(fci-&gt;seconds,tick,fci,del); zend_fci_cache_persist(&amp;fci-&gt;fcc); RETURN_LONG(id);&#125; 扩展函数内执行php用户态回调函数示例12345678910int tick(long long id,void *data)&#123; php_lib_timer_callback *fci = (php_lib_timer_callback *)data; zval result; fci-&gt;fci.retval = &amp;result; if(zend_call_function(&amp;fci-&gt;fci,&amp;fci-&gt;fcc) != SUCCESS)&#123; return NOMORE; &#125; return fci-&gt;seconds;&#125; timer 中对回调函数变量进行引用计数+1上面会发现timer::tick()函数在返回给用户空间时会做一个操作zend_fci_cache_persist(&amp;fci-&gt;fcc);，正是该调用对传入的回调函数进行饮用计数管理，告诉php内核该回调函数在c层会继续使用不用回收。代码如下1234567891011static void zend_fci_cache_persist(zend_fcall_info_cache *fci_cache)&#123; if (fci_cache-&gt;object) &#123; GC_ADDREF(fci_cache-&gt;object); &#125; if (fci_cache-&gt;function_handler-&gt;op_array.fn_flags &amp; ZEND_ACC_CLOSURE) &#123; GC_ADDREF(ZEND_CLOSURE_OBJECT(fci_cache-&gt;function_handler)); &#125;&#125; 其中GC_ADDREF（）函数很明显就是内核GC相关的api。fci_cache-&gt;function_handler 则为用户传递的回调函数真正的变量地址 如上前奏后就可以在c扩展中放心的对用户传递的变量进行操作了 timer 中结束后变量的Gc回收上面有看到php_lib_timer_callback变量实际是自己定义的结构体，包括内存也是有开发者自己分配的，可以放心的free。但是该结构体中指向的fci.fcc 则实际是php用户空间申请的变量，不能直接free,如果直接free，会引发php gc泄漏，如下警告所示: 123&gt; php timer.php/php/src/Zend/zend_closures.c(459) : Freeing 0x00007fc084e6d480 (304 bytes), script=/timer.php=== Total 1 memory leaks detected === 所以依然需要根据php内核GC的管理方式来处理用户空间的变量，也就是模拟用户空间那样对变量的管理： 12345678910111213141516171819202122static void zend_fci_cache_discard(zend_fcall_info_cache *fci_cache)&#123; if (fci_cache-&gt;object) &#123; OBJ_RELEASE(fci_cache-&gt;object); &#125; if (fci_cache-&gt;function_handler-&gt;op_array.fn_flags &amp; ZEND_ACC_CLOSURE) &#123; OBJ_RELEASE(ZEND_CLOSURE_OBJECT(fci_cache-&gt;function_handler)); &#125;&#125;static void zend_fci_params_discard(zend_fcall_info *fci)&#123; if (fci-&gt;param_count &gt; 0) &#123; uint32_t i; for (i = 0; i &lt; fci-&gt;param_count; i++) &#123; zval_ptr_dtor(&amp;fci-&gt;params[i]); &#125; efree(fci-&gt;params); &#125;&#125; 在不需要使用的时候，也需要对回调函数本身进行减引用，以及回调函数内的用户态的参数进行减引用以及变量的回收。只有做完上面这些基本的管理才能开发一个安全的扩展函数 总结总之用户空间申请的变量传递给扩展内函数使用，如果在返回给用户空间后依然会继续使用就要zval_copy或者引用计数+1,因为在返回给用户空间的时候本身用户空间gc会判断该变量是否有继续引用，否则就refcount -= 1，用户空间回收该变量，但是扩展函数内依然在访问该已经被销毁的变量。就会导致错误 只有将这些变量的引用与回收做好了才能开发出安全可靠的扩展函数","tags":[{"name":"linux","slug":"linux","permalink":"https://superver.github.io/tags/linux/"},{"name":"php","slug":"php","permalink":"https://superver.github.io/tags/php/"},{"name":"c","slug":"c","permalink":"https://superver.github.io/tags/c/"},{"name":"ext","slug":"ext","permalink":"https://superver.github.io/tags/ext/"},{"name":"refrerence","slug":"refrerence","permalink":"https://superver.github.io/tags/refrerence/"},{"name":"gc","slug":"gc","permalink":"https://superver.github.io/tags/gc/"}],"categories":[{"name":"blog","slug":"blog","permalink":"https://superver.github.io/categories/blog/"},{"name":"php","slug":"blog/php","permalink":"https://superver.github.io/categories/blog/php/"}]}],"categories":[{"name":"tool","slug":"tool","permalink":"https://superver.github.io/categories/tool/"},{"name":"resume","slug":"resume","permalink":"https://superver.github.io/categories/resume/"},{"name":"life","slug":"life","permalink":"https://superver.github.io/categories/life/"},{"name":"blog","slug":"blog","permalink":"https://superver.github.io/categories/blog/"},{"name":"nginx","slug":"blog/nginx","permalink":"https://superver.github.io/categories/blog/nginx/"},{"name":"php","slug":"blog/php","permalink":"https://superver.github.io/categories/blog/php/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://superver.github.io/tags/tool/"},{"name":"redis","slug":"redis","permalink":"https://superver.github.io/tags/redis/"},{"name":"life","slug":"life","permalink":"https://superver.github.io/tags/life/"},{"name":"nginx","slug":"nginx","permalink":"https://superver.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"https://superver.github.io/tags/linux/"},{"name":"php","slug":"php","permalink":"https://superver.github.io/tags/php/"},{"name":"c","slug":"c","permalink":"https://superver.github.io/tags/c/"},{"name":"ext","slug":"ext","permalink":"https://superver.github.io/tags/ext/"},{"name":"refrerence","slug":"refrerence","permalink":"https://superver.github.io/tags/refrerence/"},{"name":"gc","slug":"gc","permalink":"https://superver.github.io/tags/gc/"}]}